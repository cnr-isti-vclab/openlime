<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>OpenLIME Source: TextToSpeechPlayer.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.cerulean.css">

	<link type="text/css" rel="stylesheet" href="styles/openlime.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top navbar-inverse">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">OpenLIME</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="Annotation.html">Annotation</a></li><li><a href="AudioPlayer.html">AudioPlayer</a></li><li><a href="BoundingBox.html">BoundingBox</a></li><li><a href="Cache.html">Cache</a></li><li><a href="Camera.html">Camera</a></li><li><a href="Canvas.html">Canvas</a></li><li><a href="Color.html">Color</a></li><li><a href="Colormap.html">Colormap</a></li><li><a href="ColormapLegend.html">ColormapLegend</a></li><li><a href="Controller.html">Controller</a></li><li><a href="Controller2D.html">Controller2D</a></li><li><a href="ControllerFocusContext.html">ControllerFocusContext</a></li><li><a href="ControllerLens.html">ControllerLens</a></li><li><a href="ControllerPanZoom.html">ControllerPanZoom</a></li><li><a href="CoordinateSystem.html">CoordinateSystem</a></li><li><a href="Draggable.html">Draggable</a></li><li><a href="EditorSvgAnnotation.html">EditorSvgAnnotation</a></li><li><a href="Erase.html">Erase</a></li><li><a href="FocusContext.html">FocusContext</a></li><li><a href="GeoreferenceManager.html">GeoreferenceManager</a></li><li><a href="Layer.html">Layer</a></li><li><a href="LayerAnnotation.html">LayerAnnotation</a></li><li><a href="LayerAnnotationImage.html">LayerAnnotationImage</a></li><li><a href="LayerBRDF.html">LayerBRDF</a></li><li><a href="LayerCombiner.html">LayerCombiner</a></li><li><a href="LayerDstretch.html">LayerDstretch</a></li><li><a href="LayerHDR.html">LayerHDR</a></li><li><a href="LayerImage.html">LayerImage</a></li><li><a href="LayerLens.html">LayerLens</a></li><li><a href="LayerMaskedImage.html">LayerMaskedImage</a></li><li><a href="LayerMultispectral.html">LayerMultispectral</a></li><li><a href="LayerNeuralRTI.html">LayerNeuralRTI</a></li><li><a href="LayerRTI.html">LayerRTI</a></li><li><a href="LayerSvgAnnotation.html">LayerSvgAnnotation</a></li><li><a href="Layout.html">Layout</a></li><li><a href="LayoutTileImages.html">LayoutTileImages</a></li><li><a href="LayoutTiles.html">LayoutTiles</a></li><li><a href="LensDashboard.html">LensDashboard</a></li><li><a href="LensDashboardNavigator.html">LensDashboardNavigator</a></li><li><a href="LensDashboardNavigatorRadial.html">LensDashboardNavigatorRadial</a></li><li><a href="LightSphereController.html">LightSphereController</a></li><li><a href="MultispectralUI.html">MultispectralUI</a></li><li><a href="PointerManager.html">PointerManager</a></li><li><a href="Raster.html">Raster</a></li><li><a href="Raster16Bit.html">Raster16Bit</a></li><li><a href="Ruler.html">Ruler</a></li><li><a href="ScaleBar.html">ScaleBar</a></li><li><a href="Shader.html">Shader</a></li><li><a href="ShaderAnisotropicDiffusion.html">ShaderAnisotropicDiffusion</a></li><li><a href="ShaderBRDF.html">ShaderBRDF</a></li><li><a href="ShaderCombiner.html">ShaderCombiner</a></li><li><a href="ShaderDstretch.html">ShaderDstretch</a></li><li><a href="ShaderEdgeDetection.html">ShaderEdgeDetection</a></li><li><a href="ShaderFilter.html">ShaderFilter</a></li><li><a href="ShaderFilterBrightness.html">ShaderFilterBrightness</a></li><li><a href="ShaderFilterColormap.html">ShaderFilterColormap</a></li><li><a href="ShaderFilterGrayscale.html">ShaderFilterGrayscale</a></li><li><a href="ShaderFilterOpacity.html">ShaderFilterOpacity</a></li><li><a href="ShaderFilterTest.html">ShaderFilterTest</a></li><li><a href="ShaderFilterVector.html">ShaderFilterVector</a></li><li><a href="ShaderFilterVectorGlyph.html">ShaderFilterVectorGlyph</a></li><li><a href="ShaderGammaFilter.html">ShaderGammaFilter</a></li><li><a href="ShaderHDR.html">ShaderHDR</a></li><li><a href="ShaderLens.html">ShaderLens</a></li><li><a href="ShaderMultispectral.html">ShaderMultispectral</a></li><li><a href="ShaderNeural.html">ShaderNeural</a></li><li><a href="ShaderRTI.html">ShaderRTI</a></li><li><a href="Skin.html">Skin</a></li><li><a href="TextToSpeechPlayer.html">TextToSpeechPlayer</a></li><li><a href="Tile.html">Tile</a></li><li><a href="Transform.html">Transform</a></li><li><a href="UIBasic.html">UIBasic</a></li><li><a href="UIDialog.html">UIDialog</a></li><li><a href="Units.html">Units</a></li><li><a href="Util.html">Util</a></li><li><a href="Viewer.html">Viewer</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="events.list.html" class="dropdown-toggle" data-toggle="dropdown">Events<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="Camera.html#event:update">Camera#event:update</a></li><li><a href="Canvas.html#event:ready">Canvas#event:ready</a></li><li><a href="Canvas.html#event:update">Canvas#event:update</a></li><li><a href="Canvas.html#event:updateSize">Canvas#event:updateSize</a></li><li><a href="Layer.html#event:ready">Layer#event:ready</a></li><li><a href="Layer.html#event:update">Layer#event:update</a></li><li><a href="LayerAnnotation.html#event:ready">LayerAnnotation#event:ready</a></li><li><a href="LayerAnnotation.html#event:update">LayerAnnotation#event:update</a></li><li><a href="LayerAnnotationImage.html#event:ready">LayerAnnotationImage#event:ready</a></li><li><a href="LayerAnnotationImage.html#event:update">LayerAnnotationImage#event:update</a></li><li><a href="LayerBRDF.html#event:ready">LayerBRDF#event:ready</a></li><li><a href="LayerBRDF.html#event:update">LayerBRDF#event:update</a></li><li><a href="LayerCombiner.html#event:ready">LayerCombiner#event:ready</a></li><li><a href="LayerCombiner.html#event:update">LayerCombiner#event:update</a></li><li><a href="LayerDstretch.html#event:ready">LayerDstretch#event:ready</a></li><li><a href="LayerDstretch.html#event:update">LayerDstretch#event:update</a></li><li><a href="LayerHDR.html#event:ready">LayerHDR#event:ready</a></li><li><a href="LayerHDR.html#event:update">LayerHDR#event:update</a></li><li><a href="LayerImage.html#event:ready">LayerImage#event:ready</a></li><li><a href="LayerImage.html#event:update">LayerImage#event:update</a></li><li><a href="LayerLens.html#event:ready">LayerLens#event:ready</a></li><li><a href="LayerLens.html#event:update">LayerLens#event:update</a></li><li><a href="LayerMaskedImage.html#event:ready">LayerMaskedImage#event:ready</a></li><li><a href="LayerMaskedImage.html#event:update">LayerMaskedImage#event:update</a></li><li><a href="LayerMultispectral.html#event:ready">LayerMultispectral#event:ready</a></li><li><a href="LayerMultispectral.html#event:update">LayerMultispectral#event:update</a></li><li><a href="LayerNeuralRTI.html#event:ready">LayerNeuralRTI#event:ready</a></li><li><a href="LayerNeuralRTI.html#event:update">LayerNeuralRTI#event:update</a></li><li><a href="LayerRTI.html#event:ready">LayerRTI#event:ready</a></li><li><a href="LayerRTI.html#event:update">LayerRTI#event:update</a></li><li><a href="LayerSvgAnnotation.html#event:ready">LayerSvgAnnotation#event:ready</a></li><li><a href="LayerSvgAnnotation.html#event:update">LayerSvgAnnotation#event:update</a></li><li><a href="Layout.html#event:ready">Layout#event:ready</a></li><li><a href="Layout.html#event:updateSize">Layout#event:updateSize</a></li><li><a href="LayoutTileImages.html#event:ready">LayoutTileImages#event:ready</a></li><li><a href="LayoutTileImages.html#event:updateSize">LayoutTileImages#event:updateSize</a></li><li><a href="LayoutTiles.html#event:ready">LayoutTiles#event:ready</a></li><li><a href="LayoutTiles.html#event:updateSize">LayoutTiles#event:updateSize</a></li><li><a href="Shader.html#event:update">Shader#event:update</a></li><li><a href="ShaderBRDF.html#event:update">ShaderBRDF#event:update</a></li><li><a href="ShaderCombiner.html#event:update">ShaderCombiner#event:update</a></li><li><a href="ShaderDstretch.html#event:update">ShaderDstretch#event:update</a></li><li><a href="ShaderHDR.html#event:update">ShaderHDR#event:update</a></li><li><a href="ShaderLens.html#event:update">ShaderLens#event:update</a></li><li><a href="ShaderMultispectral.html#event:update">ShaderMultispectral#event:update</a></li><li><a href="ShaderNeural.html#event:update">ShaderNeural#event:update</a></li><li><a href="ShaderRTI.html#event:update">ShaderRTI#event:update</a></li><li><a href="UIDialog.html#event:closed">UIDialog#event:closed</a></li><li><a href="Viewer.html#event:draw">Viewer#event:draw</a></li><li><a href="Viewer.html#event:resize">Viewer#event:resize</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="tutorials.list.html" class="dropdown-toggle" data-toggle="dropdown">Howto<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="tutorial-getting-started.html">Getting started with OpenLIME</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="global.html#RenderingMode">RenderingMode</a></li><li><a href="global.html#addSignals">addSignals</a></li><li><a href="global.html#simplify">simplify</a></li><li><a href="global.html#smooth">smooth</a></li><li><a href="global.html#smoothToPath">smoothToPath</a></li><li><a href="global.html#taskCallback">taskCallback</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: TextToSpeechPlayer.js</h1>
    
<section>
    <article>
        <pre
            class="sunlight-highlight-javascript linenums">/**
 * @typedef {Object} TextToSpeechOptions
 * @property {string} [language='it-IT'] - Language code for speech synthesis (e.g., 'en-US', 'it-IT')
 * @property {number} [rate=1.0] - Speech rate (0.1 to 10)
 * @property {number} [volume=1.0] - Speech volume (0 to 1)
 * @property {boolean} [cleanText=true] - Whether to remove HTML tags and format text
 * @property {number} [voiceSelected=-1] - Index of preferred voice (-1 for auto-selection)
 */

/**
 * 
 * TextToSpeechPlayer provides text-to-speech functionality with extensive control options.
 * Handles voice selection, speech synthesis, text cleaning, and playback control.
 * 
 * Features:
 * - Multiple language support
 * - Automatic voice selection
 * - Text cleaning and formatting
 * - Playback controls (pause, resume, stop)
 * - Volume control with mute option
 * - Offline capability detection
 * - Chrome speech bug workarounds
 * - Page visibility handling
 * 
 * Browser Compatibility:
 * - Uses Web Speech API
 * - Implements Chrome-specific fixes
 * - Handles browser tab switching
 * - Manages page unload events
 * 
 *
 * Implementation Details
 * 
 * Chrome Bug Workarounds:
 * - Implements periodic pause/resume to prevent Chrome from stopping
 * - Uses timeout to prevent indefinite speech
 * - Handles voice loading race conditions
 * 
 * State Management:
 * ```javascript
 * {
 *     isSpeaking: boolean,    // Current speech state
 *     isPaused: boolean,      // Pause state
 *     voice: SpeechSynthesisVoice, // Selected voice
 *     isOfflineCapable: boolean,   // Offline support
 *     volume: number,         // Current volume
 *     previousVolume: number  // Pre-mute volume
 * }
 * ```
 * 
 * Event Handling:
 * - beforeunload: Stops speech on page close
 * - visibilitychange: Handles tab switching
 * - voiceschanged: Manages voice loading
 * - utterance events: Tracks speech progress
 */
class TextToSpeechPlayer {
  /**
   * Creates a new TextToSpeechPlayer instance
   * @param {TextToSpeechOptions} [options] - Configuration options
   * 
   * @example
   * ```javascript
   * const tts = new TextToSpeechPlayer({
   *     language: 'en-US',
   *     rate: 1.2,
   *     volume: 0.8,
   *     cleanText: true
   * });
   * ```
   */
  constructor(options) {
    // Default configuration
    this.config = {
      language: 'it-IT',
      rate: 1.0,
      volume: 1.0,
      cleanText: true,
      voiceSelected: -1
    };
    
    // Apply user options
    if (options) {
      Object.assign(this.config, options);
    }

    // State properties
    this.voice = null;
    this.isSpeaking = false;
    this.currentUtterance = null;
    this.isOfflineCapable = false;
    this.resumeTimer = null;
    this.timeoutTimer = null;
    this.isPaused = false;
    this.previousVolume = this.config.volume;
    this.intentionalStop = false;
    this._resolveCurrentSpeech = null;
    
    // Check if Speech Synthesis API is supported
    if (!window.speechSynthesis) {
      console.error("Speech Synthesis API is not supported in this browser");
    }
  }

  /**
   * Initializes the player by loading voices and checking capabilities
   * @returns {Promise&lt;void>}
   * @throws {Error} If voice loading fails or no suitable voices found
   * 
   * Initialization steps:
   * 1. Loads available voices
   * 2. Selects appropriate voice
   * 3. Checks offline capability
   * 4. Sets up page listeners
   */
  async initialize() {
    try {
      // Ensure Speech Synthesis API is available
      if (!window.speechSynthesis) {
        throw new Error("Speech Synthesis API is not supported in this browser");
      }
      
      // Pre-warm the speech synthesis engine with a silent utterance
      // This solves the "first click does nothing" issue in some browsers
      await this.warmUpSpeechSynthesis();
      
      await this.loadVoice();
      this.checkOfflineCapability();
      this.setupPageListeners();
      console.log("TextToSpeechPlayer initialized successfully");
      console.log(`Offline capable: ${this.isOfflineCapable}`);
      return true;
    } catch (error) {
      console.error("Failed to initialize TextToSpeechPlayer:", error);
      throw error;
    }
  }
  
  /**
   * Warms up the speech synthesis engine with a silent utterance.
   * This helps with the first-time initialization in some browsers.
   * @private
   */
  async warmUpSpeechSynthesis() {
    return new Promise((resolve) => {
      try {
        // Create a silent utterance (space character with zero volume)
        const emptyUtterance = new SpeechSynthesisUtterance(" ");
        emptyUtterance.volume = 0;
        
        // Ensure it completes quickly
        emptyUtterance.rate = 2;
        
        emptyUtterance.onend = () => {
          resolve();
        };
        
        emptyUtterance.onerror = () => {
          // Even if there's an error, we should continue
          resolve();
        };
        
        // Set a timeout in case the event doesn't fire
        setTimeout(resolve, 500);
        
        // Speak the empty utterance
        window.speechSynthesis.speak(emptyUtterance);
      } catch (e) {
        console.warn("Failed to warm up speech synthesis", e);
        resolve();
      }
    });
  }

  /**
   * Sets up event listeners for page visibility changes and unload events.
   * @private
   */
  setupPageListeners() {
    // For page close/refresh
    window.addEventListener('beforeunload', () => {
      this.stopSpeaking();
    });

    // For page visibility change (e.g., switching tabs)
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        this.stopSpeaking();
      }
    });
  }

  /**
   * Activates the TextToSpeechPlayer.
   */
  activate() {
    this.isSpeaking = true;
  }

  /**
   * Loads and selects appropriate voice for synthesis.
   * 
   * @returns {Promise&lt;SpeechSynthesisVoice>}
   * @throws {Error} If no suitable voice is found
   * @private
   */
  async loadVoice() {
    console.log(`Loading voice for language: ${this.config.language}`);
    return new Promise((resolve, reject) => {
      const synth = window.speechSynthesis;
      
      // Function to set voice based on available voices
      const setVoice = () => {
        let voices = synth.getVoices();
        
        if (voices.length === 0) {
          console.warn("No voices available for this browser");
          reject(new Error("No voices available for this browser"));
          return;
        }
        
        // Select voice based on index if provided
        if (this.config.voiceSelected >= 0 &amp;&amp; this.config.voiceSelected &lt; voices.length) {
          this.voice = voices[this.config.voiceSelected];
        } else {
          // Otherwise select by language
          const firstTwo = this.config.language.substring(0, 2);
          this.voice = voices.find(v => v.lang.startsWith(firstTwo));
        }
        
        if (this.voice) {
          console.log(`Voice loaded: ${this.voice.name}`);
          resolve(this.voice);
        } else {
          console.warn(`No suitable voice found for language: ${this.config.language}`);
          reject(new Error(`No voice available for ${this.config.language}`));
        }
      };

      // Try to set voice immediately if already available
      if (synth.getVoices().length > 0) {
        setVoice();
      } else {
        // Otherwise wait for voices to load
        synth.onvoiceschanged = () => {
          setVoice();
          synth.onvoiceschanged = null;
        };
        
        // Set a timeout in case onvoiceschanged doesn't fire
        setTimeout(() => {
          if (!this.voice) {
            console.warn("Timeout while waiting for voices to load");
            setVoice();
          }
        }, 1000);
      }
    });
  }

  /**
   * Checks if the selected voice is capable of offline speech synthesis.
   * 
   * @private
   */
  checkOfflineCapability() {
    if (this.voice) {
      // A voice is offline capable if localService is true (not false as in original code)
      this.isOfflineCapable = this.voice.localService;
    } else {
      this.isOfflineCapable = false;
    }
  }

  /**
   * Cleans text by removing HTML tags and formatting.
   * 
   * Cleaning steps:
   * 1. Removes 'omissis' class content
   * 2. Converts &lt;br> to spaces
   * 3. Strips HTML tags
   * 4. Removes escape characters
   * 5. Trims whitespace
   * 
   * @param {string} text - Text to clean
   * @returns {string} Cleaned text
   * @private
   */
  cleanTextForSpeech(text) {
    if (!text) return "";
    
    // Remove content of any HTML tag with class "omissis" (with or without escaped quotes)
    let cleanedText = text.replace(/&lt;[^>]+class=(\"omissis\"|"omissis")[^>]*>[\s\S]*?&lt;\/[^>]+>/g, "");
    // Substitute &lt;br> tag with whitespace " "
    cleanedText = cleanedText.replace(/&lt;br\s*\/?>/gi, " ");
    // Remove HTML tags
    cleanedText = cleanedText.replace(/&lt;\/?[^>]+(>|$)/g, "");
    // Remove escape characters like \n, \t, etc.
    cleanedText = cleanedText.replace(/\\[nrt]/g, " ");
    // Trim leading and trailing whitespace
    return cleanedText.trim();
  }

  /**
   * Speaks the provided text
   * @param {string} text - Text to be spoken
   * @returns {Promise&lt;void>}
   * @throws {Error} If speech synthesis fails or times out
   * 
   * Processing steps:
   * 1. Cancels any ongoing speech
   * 2. Cleans input text if enabled
   * 3. Creates utterance with current settings
   * 4. Handles speech synthesis
   * 5. Manages timeouts and Chrome workarounds
   * 
   * @example
   * ```javascript
   * await tts.speakText("Hello, world!");
   * ```
   */
  async speakText(text) {
    // First stop any current speech
    this.stopSpeaking();
    
    if (!text) {
      console.warn("No text provided to speak");
      return;
    }

    if (!this.voice) {
      console.error("Voice not loaded. Please initialize TextToSpeechPlayer first.");
      return;
    }

    if (!this.isOfflineCapable &amp;&amp; !navigator.onLine) {
      console.error("No internet connection and offline speech is not available.");
      return;
    }

    // Set speaking state
    this.isSpeaking = true;
    this.isPaused = false;
    
    // Process text if needed
    let cleanedText = text;
    if (this.config.cleanText) {
      cleanedText = this.cleanTextForSpeech(text);
    }
    
    if (!cleanedText) {
      console.warn("Text is empty after cleaning");
      this.isSpeaking = false;
      return;
    }
    
    console.log("Attempting to speak:", cleanedText);

    const synth = window.speechSynthesis;
    
    // Ensure the synthesis system is active (fixes Chrome/Firefox first-time issues)
    synth.cancel();
    
    // Store whether we intentionally cancelled speech
    this.intentionalStop = false;
    
    try {
      // Create new utterance
      this.currentUtterance = new SpeechSynthesisUtterance(cleanedText);
      this.currentUtterance.lang = this.config.language;
      this.currentUtterance.voice = this.voice;
      this.currentUtterance.rate = this.config.rate;
      this.currentUtterance.volume = this.config.volume;

      // Handle speaking process
      await new Promise((resolve, reject) => {
        // Store the resolve function so we can call it from stopSpeaking
        this._resolveCurrentSpeech = resolve;
        
        this.currentUtterance.onend = () => {
          resolve('completed');
        };
        
        this.currentUtterance.onerror = (event) => {
          // Don't treat intentional stops as errors
          if (this.intentionalStop &amp;&amp; event.error === 'interrupted') {
            console.log("Speech intentionally interrupted");
            resolve('interrupted');
          } else {
            console.error("Speech error:", event);
            reject(event);
          }
        };

        // Start speaking
        synth.speak(this.currentUtterance);
        
        // Force Chrome to start speaking immediately (fixes first-play issues)
        if (!this.isPaused &amp;&amp; synth.speaking) {
          synth.pause();
          synth.resume();
        }
        
        // Timeout to prevent speech from running indefinitely
        const maxSpeechTime = Math.max(5000, cleanedText.length * 100); // At least 5 seconds
        this.timeoutTimer = setTimeout(() => {
          if (synth.speaking &amp;&amp; this.isSpeaking) {
            console.warn("Speech synthesis taking too long. Resetting...");
            this.intentionalStop = true;
            this.stopSpeaking();
            resolve('timeout');
          }
        }, maxSpeechTime);
        
        // Workaround for Chrome bug - resume speech every 10 seconds
        this.resumeTimer = setInterval(() => {
          if (!synth.speaking) {
            clearInterval(this.resumeTimer);
            this.resumeTimer = null;
          } else if (!this.isPaused) {
            // Only pause and resume if not manually paused
            synth.pause();
            synth.resume();
          }
        }, 10000);
      });
    } catch (error) {
      // Only log errors that aren't related to intentional stopping
      if (!(this.intentionalStop &amp;&amp; error.error === 'interrupted')) {
        console.error("Error during speech:", error);
      }
    } finally {
      // Clean up regardless of outcome
      if (this.isSpeaking) {
        this.stopSpeaking();
      }
    }
  }

  /**
   * Pauses or resumes speech synthesis
   * @param {boolean} enable - True to pause, false to resume
   * 
   * @example
   * ```javascript
   * // Pause speech
   * tts.pauseSpeaking(true);
   * 
   * // Resume speech
   * tts.pauseSpeaking(false);
   * ```
   */
  pauseSpeaking(enable) {
    if (!window.speechSynthesis || !this.isSpeaking) {
      console.log("No speech in progress to pause/resume");
      return;
    }
    
    const synth = window.speechSynthesis;
    
    if (enable &amp;&amp; !this.isPaused) {
      // Pause speech
      synth.pause();
      this.isPaused = true;
      
      // Clear the resume timer when pausing
      if (this.resumeTimer) {
        clearInterval(this.resumeTimer);
        this.resumeTimer = null;
      }
    } else if (!enable &amp;&amp; this.isPaused) {
      // Resume speech
      synth.resume();
      this.isPaused = false;
      
      // Restart the resume timer for Chrome bug workaround
      this.resumeTimer = setInterval(() => {
        if (!synth.speaking) {
          clearInterval(this.resumeTimer);
          this.resumeTimer = null;
        } else {
          synth.pause();
          synth.resume();
        }
      }, 10000);
    }
  }

  /**
   * Mutes or unmutes audio output
   * @param {boolean} enable - True to mute, false to unmute
   * 
   * @example
   * ```javascript
   * // Mute audio
   * tts.mute(true);
   * 
   * // Restore previous volume
   * tts.mute(false);
   * ```
   */
  mute(enable) {
    if (enable) {
      this.previousVolume = this.config.volume;
      this.config.volume = 0;
    } else {
      this.config.volume = this.previousVolume;
    }
    
    // Update current utterance if speaking
    if (this.currentUtterance) {
      this.currentUtterance.volume = this.config.volume;
    }
  }

  /**
   * Stops current speech synthesis
   * Cleans up resources and resets state
   */
  stopSpeaking() {
    const synth = window.speechSynthesis;
    
    // Mark that we're intentionally stopping speech to handle the error properly
    this.intentionalStop = true;
    
    // Cancel speech if speaking
    if (synth &amp;&amp; synth.speaking) {
      try {
        synth.cancel();
      } catch (e) {
        console.error("Error cancelling speech:", e);
      }
    }
    
    // Clear timers
    if (this.resumeTimer) {
      clearInterval(this.resumeTimer);
      this.resumeTimer = null;
    }
    
    if (this.timeoutTimer) {
      clearTimeout(this.timeoutTimer);
      this.timeoutTimer = null;
    }
    
    // Resolve any pending promise to prevent unhandled rejections
    if (this._resolveCurrentSpeech) {
      this._resolveCurrentSpeech('stopped');
      this._resolveCurrentSpeech = null;
    }
    
    // Reset state
    this.currentUtterance = null;
    this.isSpeaking = false;
    this.isPaused = false;
  }
}

export { TextToSpeechPlayer }</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>

	<div class='jsdoc-message'>ISTI - CNR & CRS4 - ViC</div>


<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.4</a>
	
		on 2025-09-06T18:51:26+00:00
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>
