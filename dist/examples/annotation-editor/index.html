<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenLIME - Annotation Editor</title>
    <link rel="stylesheet" href="../../css/skin.css" />
    <link rel="stylesheet" href="../examples.css" />
    <style>
        html,
        body {
            color: #3f0099;
            font-family: Arial, sans-serif;
            background-color: #9c98cc80;
        }

        a {
            color: #3f0099;
        }

        .headline {
            padding: 15px 0px 10px 0px;
            margin-bottom: 5px;
            margin-top: 0px;
        }

        .openlime {
            height: 80%;
            top: 2px;
            background-color: #fff;
        }

        .openlime-toolbar {
            background-color: #766dd680;
            border-radius: 8px;
            flex-direction: column;
            top: 10px;
            bottom: auto;
            right: 5px;
        }

        .openlime-dialog-background {
            background-color: rgba(255, 255, 255, 0.5);
        }

        .openlime-dialog {
            background: #766dd6ff;
            color: white;
            width: 400px;
            height: 300px;
        }

        .openlime-customInfo.active .openlime-button-off {
            visibility: visible !important;
        }

        .openlime-customInfo .openlime-button-off {
            visibility: hidden !important;
        }

        .openlime-attribution {
            left: auto;
            right: 20px;
            bottom: -30px;
        }

        .openlime-attribution a {
            color: rgb(88, 88, 88);
        }
    </style>
</head>

<body>
    <!-- Web page -->
    <h1 class="headline">OpenLIME - Annotation Editor (Flask Backend)</h1>

    <div class="openlime"></div>
    <script src="../../js/openlime.js"></script>
    <script>
        // Check URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const editorEnable = urlParams.has('editor');

        // Create an OpenLIME canvas into openlime
        const lime = new OpenLIME.Viewer('.openlime');
        lime.camera.bounded = false;

        // Fetch a (custom) skin. A skin is a set of visual elements for the web page.
        OpenLIME.Skin.setUrl('../../skin/skin.svg');

        // Create a custom dialog
        let openlime = document.querySelector('.openlime');
        let infoDialog = new OpenLIME.UIDialog(openlime, { modal: true });
        infoDialog.hide();

        // Create an image layer and add it to the canvas
        const layer = new OpenLIME.Layer({
            type: 'image',
            layout: 'deepzoom',
            url: '../../assets/parrot/parrot.dzi'
        });
        lime.addLayer('Base', layer);

        // Zoom to annotation function (calculates zoom from SVG geometry)
        function zoomToAnnotation(anno) {
            if ('state' in anno) {
                lime.canvas.setState(anno.state, 1500, 'ease-in-out');
            }
            infoDialog.setContent(anno.description || 'No description available');
            infoDialog.show();
            return true;
        }

        // Helper function to extract coordinates from SVG path data
        function extractCoordsFromPath(pathData) {
            const coords = [];
            // Simple regex to extract numeric coordinates from path data
            const matches = pathData.match(/-?\d+\.?\d*/g);
            if (matches) {
                for (let i = 0; i < matches.length - 1; i += 2) {
                    coords.push({
                        x: parseFloat(matches[i]),
                        y: parseFloat(matches[i + 1])
                    });
                }
            }
            return coords;
        }

        // Define annotation parameters
        let annotationServer = 'http://127.0.0.1:3000/ol'; // Use 127.0.0.1 instead of localhost for consistency

        const classParam = {
            '': { stroke: '#000', label: '' },
            'class1': { stroke: '#770', label: 'A' },
            'class2': { stroke: '#707', label: 'B' },
            'class3': { stroke: '#777', label: 'C' },
            'class4': { stroke: '#070', label: 'D' },
            'class5': { stroke: '#007', label: 'E' },
            'class6': { stroke: '#077', label: 'F' },
        };

        let aOptions = {
            label: 'Annotations',
            layout: layer.layout,
            type: 'svg_annotations',
            style: ` 
            .openlime-annotation { pointer-events:stroke; opacity: 0.7; }
            .openlime-annotation:hover { cursor:pointer; opacity: 1.0; }

            :focus { fill:yellow; }
            path { fill:rgba(32, 32, 32, 0.8); stroke:#aaa; stroke-width:2px; vector-effect:non-scaling-stroke; pointer-events:all; }
            path:hover { cursor:pointer; stroke:#f00; }
            .selected { stroke-width:3; }
            
            /* Pin styling */
            .pin { cursor:pointer; fill:rgba(32, 32, 32, 0.8); stroke:#aaa; stroke-width:2px; vector-effect:non-scaling-stroke; }
            .pin text { cursor:pointer; user-select:none; font-family:arial; stroke:none; font-size:6px; fill:#fff; alignment-baseline:middle; text-anchor:middle; }
            .pin.hidden { visibility:hidden; }
            
            /* Line styling */
            .line { cursor:pointer; fill:none; stroke:#aaa; stroke-width:4px; vector-effect:non-scaling-stroke; }
            .line.selected { stroke:#f00; stroke-width:6px; }
            `,
            annotations: annotationServer,
            annotationUpdate: (anno, transform) => {
                // Update pin sizes based on zoom level
                let size = 36 / transform.z; // Base size of 36px divided by zoom level
                if (size !== anno.previous_size) {
                    anno.elements.forEach(e => {
                        if (e.classList.contains('pin')) {
                            e.setAttribute('width', size + 'px');
                            e.setAttribute('height', size + 'px');
                        }
                    });
                    anno.previous_size = size;
                }
            },
            onClick: (anno) => {
                zoomToAnnotation(anno);
                console.log('=== ANNOTATION CLICK DEBUG ===');
                console.log('Clicked annotation object:', anno);
                console.log('Annotation keys:', Object.keys(anno));
                console.log('Has state?', 'state' in anno);
                console.log('Has bbox?', 'bbox' in anno);
                console.log('State content:', anno.state);
                console.log('Bbox content:', anno.bbox);
            },
            classes: classParam
        };

        // Create an annotation layer and add it to the canvas
        const anno = new OpenLIME.LayerAnnotation(aOptions);
        lime.addLayer('anno', anno);

        // Add event listener for annotation loading
        anno.addEvent('loaded', () => {
            const count = anno.annotations ? anno.annotations.length : 0;
            console.log('Annotations loaded successfully! Count:', count);
            console.log('Annotations loaded:', anno.annotations);

            // Check if annotations failed to load
            if (!anno.annotations || anno.annotations.length === 0) {
                console.warn('No annotations found - check server connection');
            } else {
                // Debug annotation structure in detail
                if (anno.annotations.length > 0) {
                    const firstAnno = anno.annotations[0];
                    console.log('First annotation structure:', firstAnno);
                    console.log('First annotation keys:', Object.keys(firstAnno));
                    console.log('Has state?', 'state' in firstAnno);
                    console.log('Has bbox?', 'bbox' in firstAnno);
                    console.log('Has id?', 'id' in firstAnno);
                    console.log('Has label?', 'label' in firstAnno);

                    if (firstAnno.state) {
                        console.log('State content:', firstAnno.state);
                    }
                    if (firstAnno.bbox) {
                        console.log('Bbox content:', firstAnno.bbox);
                    }
                }

                // Debug pin visibility
                setTimeout(() => {
                    const shadow = anno.overlayElement.shadowRoot;
                    if (shadow) {
                        const pins = shadow.querySelectorAll('.pin');
                        const lines = shadow.querySelectorAll('.line');
                        console.log(`Found ${pins.length} pins and ${lines.length} lines in DOM`);

                        // Log pin details
                        pins.forEach((pin, index) => {
                            const rect = pin.getBoundingClientRect();
                            console.log(`Pin ${index}:`, {
                                element: pin,
                                boundingRect: rect,
                                visibility: getComputedStyle(pin).visibility,
                                display: getComputedStyle(pin).display,
                                width: pin.getAttribute('width'),
                                height: pin.getAttribute('height')
                            });
                        });
                    }
                }, 1000);
            }
        });

        // Check if editor mode is enabled
        if (editorEnable) {
            // Create a SVG annotation Editor
            console.log('Editor mode enabled');
            eOptions = {
                ...aOptions,
                enableState: true, // Enable state management for annotations
            };

            const editor = new OpenLIME.EditorSvgAnnotation(lime, anno, eOptions);

            editor.createCallback = (anno) => {
                console.log("Created annotation: ", anno);
                processRequest(anno, 'create');
                return true;
            };

            editor.deleteCallback = (anno) => {
                console.log("Deleted annotation: ", anno);
                processRequest(anno, 'delete');
                return true;
            };

            editor.updateCallback = (anno) => {
                console.log("Updated annotation: ", anno);
                processRequest(anno, 'update');
                return true;
            };
        }

        // Create a User Interface 
        const ui = new OpenLIME.UIBasic(lime);

        // Get a subset of pre-defined actions to work on it
        let { help, home, layers, fullscreen, light, zoomin, zoomout } = ui.actions;

        // Remove light from the toolbar
        light.display = false;

        // Add help, zoomin and zoomout to the toolbar
        help.display = true;
        zoomin.display = true;
        zoomout.display = true;

        // Add configured actions to the toolbar
        ui.actions = { help, home, layers, fullscreen, light, zoomin, zoomout };

        // Add image attribution 
        ui.attribution = `OpenLIME with Flask Backend - <a href="https://github.com/cnr-isti-vclab/openlime">OpenLIME Project</a>`;

        // Callback function to send http requests to the Annotation server
        async function processRequest(anno, action) {
            console.log(`Processing ${action} request...`);

            let method = "GET";
            let url = `${annotationServer}`;
            let body = "";

            switch (action) {
                case "create":
                    method = "POST";
                    url = `${annotationServer}`;
                    body = JSON.stringify(anno);
                    break;
                case "update":
                    method = "PUT";
                    url = `${annotationServer}/${anno.id}`;
                    body = JSON.stringify(anno);
                    break;
                case "delete":
                    method = "DELETE";
                    url = `${annotationServer}/${anno.id}`;
                    body = "";
                    break;
                default:
                    break;
            }

            try {
                console.log(`Sending ${method} request to ${url}`);

                const response = await fetch(url, {
                    method: method,
                    mode: 'cors',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json',
                    },
                    body: body
                });

                if (!response.ok) {
                    const message = `An error has occurred: ${response.status} ${response.statusText}`;
                    console.error(`Request failed: ${message}`);
                    alert(message);
                    throw new Error(message);
                }

                let json = await response.json();

                if (json.status == 'error') {
                    console.error(`Server error: ${json.message}`);
                    alert(json.message);
                } else {
                    console.log(`${action} successful`);
                    console.log(`${action} response:`, json);
                }

            } catch (error) {
                console.error(`Network error: ${error.message}`);
                console.error('Request failed:', error);
                alert(`Network error: ${error.message}`);
            }
        }

        // Test server connection on page load
        setTimeout(async () => {
            try {
                console.log('Testing server connection...');
                const response = await fetch(annotationServer, {
                    method: 'GET',
                    mode: 'cors',
                    headers: {
                        'Accept': 'application/json',
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    console.log(`Server connected! Found ${data.length || 0} annotations`);
                } else {
                    console.log(`Server responded with status: ${response.status}`);
                }
            } catch (error) {
                console.error(`Server connection failed: ${error.message}`);
                console.error('Server connection test failed:', error);
            }
        }, 1000);

        console.log('OpenLIME initialization complete');
    </script>
</body>

</html>